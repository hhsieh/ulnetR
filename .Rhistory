zz <- function(x) which(inv[,x]!=0)[1] #this gives the first node of each compartment as a representative of the compartment label
compartment <- sapply(1:nrow(dist), zz)
g <- graph.adjacency(DM) #generate a graph
between <- function(x) betweenness(g, directed=FALSE)[x] #betweenness centralities of nodes
close <- function(x) closeness(g, mode = "out")[x] #closeness centralities of nodes
degree_centrality <- function(x) length(which(DM[,x]==1)) #degree centralities of nodes
vertices <- data.frame(id, compartment, compartment_size, betweenness_ct = between, closeness_ct = close, degree_ct = degree_centrality)
#vertices <- data.frame(id, cmtsize)
for_compsizefreq <- unique(vertices[,c(2,3)])
#compsize <- for_compsizefreq$cmtsize
#cmtsize_freq <- table(compsize)
#compartment_size_freq <- table(cmtsize)
return(list(nodes = vertices, edges = edges, compartments_table = table(for_compsizefreq)))
}
nt(20)
nt_exp(20,0.04)
recnet <- function(d) {
#based on user-defined threshold distance, d, to create an adjancency matrix of nodes
DM <- dist[] < d
diag(DM) = 0
I <- diag(1, nrow=nrow(dist), ncol=ncol(dist))
#the application of the fundamental matrix of Markov Chain to generate information of comparments
D <- matrix(0, nrow=nrow(dist), ncol = ncol(dist))
D <- sapply(1:nrow(dist), function(z) DM[,z]/(z+1))
inv <- solve(I-D)
# collect node properties of the network
x_cord <- function(x) data$x_cord[x] #x-coordinates of nodes
y_cord <- function(x) data$y_cord[x] #y-coordinates of nodes
cmtsize <- function(x) length(which(inv[,x]!=0)) #compartment sizes of nodes
comp <- function(x) which(inv[,x]!=0)[1] #compartment identities
g <- graph.adjacency(DM) #generate a graph
between <- function(x) betweenness(g, directed=FALSE)[x] #betweenness centralities of nodes
close <- function(x) closeness(g, mode = "out")[x] #closeness centralities of nodes
degree_centrality <- function(x) length(which(DM[,x]==1)) #degree centralities of nodes
node_prop <- list()
N <- nrow(dist)
for (i in 1:N) {
node_prop[[i]] = data.frame(x_cord = x_cord(i), y_cord = y_cord(i), compartment_id = comp(i), comp_size = cmtsize(i),
between_ct = between(i), close_ct = close(i), degree_ct = degree_centrality(i)
)
}
nodeproperties <- do.call(rbind, node_prop)
# based on user-defined threshold distance, remove nodes in comparmtnets of which distance to any of the plot margins < d
p1 <- nodeproperties$compartment_id[which(nodeproperties$y_cord > 270 - d)]
p2 <- nodeproperties$compartment_id[which(nodeproperties$y_cord < -270 + d)]
p3 <- nodeproperties$compartment_id[which(nodeproperties$x_cord < -240 + d)]
p4 <- nodeproperties$compartment_id[which(nodeproperties$x_cord > 240 - d)]
unidt1 <- unique(p1)
unidt2 <- unique(p2)
unidt3 <- unique(p3)
unidt4 <- unique(p4)
unidt <- unique(c(unidt1, unidt2, unidt3, unidt4))
library(Hmisc) #import Hmisc for dropping rows to be deleted due to the threshold distance
filtered_nodes <- subset(nodeproperties, compartment_id %nin% unidt)
# produce an edge table
edg_from <- function(x) replicate(length(which(DM[,x]!=0)),x)
edg_to <- function(x) which(DM[,x]!=0)
X_cord_from <- function(x) replicate(length(edg_from(x)), myCsv$Xplot[x])
Y_cord_from <- function(x) replicate(length(edg_from(x)), myCsv$Yplot[x])
X_cord_to <- function(x) myCsv$Xplot[which(DM[,x]!=0)]
Y_cord_to <- function(x) myCsv$Yplot[which(DM[,x]!=0)]
zz <- function(x) which(inv[,x]!=0)[1]
comp <- sapply(1:nrow(dist), zz)
compar <- function(x) replicate(length(which(DM[,x]!=0)), comp[x])
edg_f <- list()
N <- nrow(dist)
for (i in 1:N) {
edg_f[[i]] = data.frame(edge_from = edg_from(i), edge_to = edg_to(i), X_cord_from = X_cord_from(i), Y_cord_from = Y_cord_from(i), X_cord_to = X_cord_to(i), Y_cord_to = Y_cord_to(i), compartment_id = compar(i))
}
edges <- do.call(rbind, edg_f)
filtered_edges <- subset(edges, compartment_id %nin% unidt)
filtered_edges <- filtered_edges[,c(1:6)]
#return(filtered_edges)
networkstats <- unique(filtered_nodes[,c(4,5)])
compsize <- networkstats$comp_size
compsize_freq <- table(compsize)
return(list(nodes = filtered_nodes, edges = filtered_edges, compsize = compsize, networkstats = networkstats))
}
recnet(20)
recnet <- function(d) {
#based on user-defined threshold distance, d, to create an adjancency matrix of nodes
DM <- dist[] < d
diag(DM) = 0
I <- diag(1, nrow=nrow(dist), ncol=ncol(dist))
#the application of the fundamental matrix of Markov Chain to generate information of comparments
D <- matrix(0, nrow=nrow(dist), ncol = ncol(dist))
D <- sapply(1:nrow(dist), function(z) DM[,z]/(z+1))
inv <- solve(I-D)
# collect node properties of the network
x_cord <- function(x) data$x_cord[x] #x-coordinates of nodes
y_cord <- function(x) data$y_cord[x] #y-coordinates of nodes
cmtsize <- function(x) length(which(inv[,x]!=0)) #compartment sizes of nodes
comp <- function(x) which(inv[,x]!=0)[1] #compartment identities
g <- graph.adjacency(DM) #generate a graph
between <- function(x) betweenness(g, directed=FALSE)[x] #betweenness centralities of nodes
close <- function(x) closeness(g, mode = "out")[x] #closeness centralities of nodes
degree_centrality <- function(x) length(which(DM[,x]==1)) #degree centralities of nodes
node_prop <- list()
N <- nrow(dist)
for (i in 1:N) {
node_prop[[i]] = data.frame(x_cord = x_cord(i), y_cord = y_cord(i), compartment_id = comp(i), comp_size = cmtsize(i),
between_ct = between(i), close_ct = close(i), degree_ct = degree_centrality(i)
)
}
nodeproperties <- do.call(rbind, node_prop)
# based on user-defined threshold distance, remove nodes in comparmtnets of which distance to any of the plot margins < d
p1 <- nodeproperties$compartment_id[which(nodeproperties$y_cord > 270 - d)]
p2 <- nodeproperties$compartment_id[which(nodeproperties$y_cord < -270 + d)]
p3 <- nodeproperties$compartment_id[which(nodeproperties$x_cord < -240 + d)]
p4 <- nodeproperties$compartment_id[which(nodeproperties$x_cord > 240 - d)]
unidt1 <- unique(p1)
unidt2 <- unique(p2)
unidt3 <- unique(p3)
unidt4 <- unique(p4)
unidt <- unique(c(unidt1, unidt2, unidt3, unidt4))
library(Hmisc) #import Hmisc for dropping rows to be deleted due to the threshold distance
filtered_nodes <- subset(nodeproperties, compartment_id %nin% unidt)
# produce an edge table
edg_from <- function(x) replicate(length(which(DM[,x]!=0)),x)
edg_to <- function(x) which(DM[,x]!=0)
X_cord_from <- function(x) replicate(length(edg_from(x)), myCsv$Xplot[x])
Y_cord_from <- function(x) replicate(length(edg_from(x)), myCsv$Yplot[x])
X_cord_to <- function(x) myCsv$Xplot[which(DM[,x]!=0)]
Y_cord_to <- function(x) myCsv$Yplot[which(DM[,x]!=0)]
zz <- function(x) which(inv[,x]!=0)[1]
comp <- sapply(1:nrow(dist), zz)
compar <- function(x) replicate(length(which(DM[,x]!=0)), comp[x])
edg_f <- list()
N <- nrow(dist)
for (i in 1:N) {
edg_f[[i]] = data.frame(edge_from = edg_from(i), edge_to = edg_to(i), X_cord_from = X_cord_from(i), Y_cord_from = Y_cord_from(i), X_cord_to = X_cord_to(i), Y_cord_to = Y_cord_to(i), compartment_id = compar(i))
}
edges <- do.call(rbind, edg_f)
filtered_edges <- subset(edges, compartment_id %nin% unidt)
filtered_edges <- filtered_edges[,c(1:6)]
#return(filtered_edges)
networkstats <- unique(filtered_nodes[,c(3,4)])
compsize <- networkstats$comp_size
compsize_freq <- table(compsize)
return(list(nodes = filtered_nodes, edges = filtered_edges, compsize = compsize, compsize_freq = compsize_freq))
}
recnet(20)
recnet <- function(d) {
#based on user-defined threshold distance, d, to create an adjancency matrix of nodes
DM <- dist[] < d
diag(DM) = 0
I <- diag(1, nrow=nrow(dist), ncol=ncol(dist))
#the application of the fundamental matrix of Markov Chain to generate information of comparments
D <- matrix(0, nrow=nrow(dist), ncol = ncol(dist))
D <- sapply(1:nrow(dist), function(z) DM[,z]/(z+1))
inv <- solve(I-D)
# collect node properties of the network
x_cord <- function(x) data$x_cord[x] #x-coordinates of nodes
y_cord <- function(x) data$y_cord[x] #y-coordinates of nodes
cmtsize <- function(x) length(which(inv[,x]!=0)) #compartment sizes of nodes
comp <- function(x) which(inv[,x]!=0)[1] #compartment identities
g <- graph.adjacency(DM) #generate a graph
between <- function(x) betweenness(g, directed=FALSE)[x] #betweenness centralities of nodes
close <- function(x) closeness(g, mode = "out")[x] #closeness centralities of nodes
degree_centrality <- function(x) length(which(DM[,x]==1)) #degree centralities of nodes
node_prop <- list()
N <- nrow(dist)
for (i in 1:N) {
node_prop[[i]] = data.frame(x_cord = x_cord(i), y_cord = y_cord(i), compartment_id = comp(i), comp_size = cmtsize(i),
between_ct = between(i), close_ct = close(i), degree_ct = degree_centrality(i)
)
}
nodeproperties <- do.call(rbind, node_prop)
# based on user-defined threshold distance, remove nodes in comparmtnets of which distance to any of the plot margins < d
p1 <- nodeproperties$compartment_id[which(nodeproperties$y_cord > 270 - d)]
p2 <- nodeproperties$compartment_id[which(nodeproperties$y_cord < -270 + d)]
p3 <- nodeproperties$compartment_id[which(nodeproperties$x_cord < -240 + d)]
p4 <- nodeproperties$compartment_id[which(nodeproperties$x_cord > 240 - d)]
unidt1 <- unique(p1)
unidt2 <- unique(p2)
unidt3 <- unique(p3)
unidt4 <- unique(p4)
unidt <- unique(c(unidt1, unidt2, unidt3, unidt4))
library(Hmisc) #import Hmisc for dropping rows to be deleted due to the threshold distance
filtered_nodes <- subset(nodeproperties, compartment_id %nin% unidt)
# produce an edge table
edg_from <- function(x) replicate(length(which(DM[,x]!=0)),x)
edg_to <- function(x) which(DM[,x]!=0)
X_cord_from <- function(x) replicate(length(edg_from(x)), myCsv$Xplot[x])
Y_cord_from <- function(x) replicate(length(edg_from(x)), myCsv$Yplot[x])
X_cord_to <- function(x) myCsv$Xplot[which(DM[,x]!=0)]
Y_cord_to <- function(x) myCsv$Yplot[which(DM[,x]!=0)]
zz <- function(x) which(inv[,x]!=0)[1]
comp <- sapply(1:nrow(dist), zz)
compar <- function(x) replicate(length(which(DM[,x]!=0)), comp[x])
edg_f <- list()
N <- nrow(dist)
for (i in 1:N) {
edg_f[[i]] = data.frame(edge_from = edg_from(i), edge_to = edg_to(i), X_cord_from = X_cord_from(i), Y_cord_from = Y_cord_from(i), X_cord_to = X_cord_to(i), Y_cord_to = Y_cord_to(i), compartment_id = compar(i))
}
edges <- do.call(rbind, edg_f)
filtered_edges <- subset(edges, compartment_id %nin% unidt)
filtered_edges <- filtered_edges[,c(1:6)]
#return(filtered_edges)
networkstats <- unique(filtered_nodes[,c(3,4)])
compsize <- networkstats$comp_size
compsize_freq <- table(compsize)
return(list(nodes = filtered_nodes, edges = filtered_edges, compsize = compsize, compsize_freq = table(networkstats)))
}
recnet(20)
recnet <- function(d) {
#based on user-defined threshold distance, d, to create an adjancency matrix of nodes
DM <- dist[] < d
diag(DM) = 0
I <- diag(1, nrow=nrow(dist), ncol=ncol(dist))
#the application of the fundamental matrix of Markov Chain to generate information of comparments
D <- matrix(0, nrow=nrow(dist), ncol = ncol(dist))
D <- sapply(1:nrow(dist), function(z) DM[,z]/(z+1))
inv <- solve(I-D)
# collect node properties of the network
x_cord <- function(x) data$x_cord[x] #x-coordinates of nodes
y_cord <- function(x) data$y_cord[x] #y-coordinates of nodes
cmtsize <- function(x) length(which(inv[,x]!=0)) #compartment sizes of nodes
comp <- function(x) which(inv[,x]!=0)[1] #compartment identities
g <- graph.adjacency(DM) #generate a graph
between <- function(x) betweenness(g, directed=FALSE)[x] #betweenness centralities of nodes
close <- function(x) closeness(g, mode = "out")[x] #closeness centralities of nodes
degree_centrality <- function(x) length(which(DM[,x]==1)) #degree centralities of nodes
node_prop <- list()
N <- nrow(dist)
for (i in 1:N) {
node_prop[[i]] = data.frame(x_cord = x_cord(i), y_cord = y_cord(i), compartment_id = comp(i), comp_size = cmtsize(i),
between_ct = between(i), close_ct = close(i), degree_ct = degree_centrality(i)
)
}
nodeproperties <- do.call(rbind, node_prop)
# based on user-defined threshold distance, remove nodes in comparmtnets of which distance to any of the plot margins < d
p1 <- nodeproperties$compartment_id[which(nodeproperties$y_cord > 270 - d)]
p2 <- nodeproperties$compartment_id[which(nodeproperties$y_cord < -270 + d)]
p3 <- nodeproperties$compartment_id[which(nodeproperties$x_cord < -240 + d)]
p4 <- nodeproperties$compartment_id[which(nodeproperties$x_cord > 240 - d)]
unidt1 <- unique(p1)
unidt2 <- unique(p2)
unidt3 <- unique(p3)
unidt4 <- unique(p4)
unidt <- unique(c(unidt1, unidt2, unidt3, unidt4))
library(Hmisc) #import Hmisc for dropping rows to be deleted due to the threshold distance
filtered_nodes <- subset(nodeproperties, compartment_id %nin% unidt)
# produce an edge table
edg_from <- function(x) replicate(length(which(DM[,x]!=0)),x)
edg_to <- function(x) which(DM[,x]!=0)
X_cord_from <- function(x) replicate(length(edg_from(x)), myCsv$Xplot[x])
Y_cord_from <- function(x) replicate(length(edg_from(x)), myCsv$Yplot[x])
X_cord_to <- function(x) myCsv$Xplot[which(DM[,x]!=0)]
Y_cord_to <- function(x) myCsv$Yplot[which(DM[,x]!=0)]
zz <- function(x) which(inv[,x]!=0)[1]
comp <- sapply(1:nrow(dist), zz)
compar <- function(x) replicate(length(which(DM[,x]!=0)), comp[x])
edg_f <- list()
N <- nrow(dist)
for (i in 1:N) {
edg_f[[i]] = data.frame(edge_from = edg_from(i), edge_to = edg_to(i), X_cord_from = X_cord_from(i), Y_cord_from = Y_cord_from(i), X_cord_to = X_cord_to(i), Y_cord_to = Y_cord_to(i), compartment_id = compar(i))
}
edges <- do.call(rbind, edg_f)
filtered_edges <- subset(edges, compartment_id %nin% unidt)
filtered_edges <- filtered_edges[,c(1:6)]
#return(filtered_edges)
networkstats <- unique(filtered_nodes[,c(3,4)])
compsize <- networkstats$comp_size
compsize_freq <- table(compsize)
return(list(nodes = filtered_nodes, edges = filtered_edges, compsize = compsize, compsize_freq = table(networkstats)))
}
recnet(20)
recnet <- function(d) {
#based on user-defined threshold distance, d, to create an adjancency matrix of nodes
DM <- dist[] < d
diag(DM) = 0
I <- diag(1, nrow=nrow(dist), ncol=ncol(dist))
#the application of the fundamental matrix of Markov Chain to generate information of comparments
D <- matrix(0, nrow=nrow(dist), ncol = ncol(dist))
D <- sapply(1:nrow(dist), function(z) DM[,z]/(z+1))
inv <- solve(I-D)
# collect node properties of the network
x_cord <- function(x) data$x_cord[x] #x-coordinates of nodes
y_cord <- function(x) data$y_cord[x] #y-coordinates of nodes
cmtsize <- function(x) length(which(inv[,x]!=0)) #compartment sizes of nodes
comp <- function(x) which(inv[,x]!=0)[1] #compartment identities
g <- graph.adjacency(DM) #generate a graph
between <- function(x) betweenness(g, directed=FALSE)[x] #betweenness centralities of nodes
close <- function(x) closeness(g, mode = "out")[x] #closeness centralities of nodes
degree_centrality <- function(x) length(which(DM[,x]==1)) #degree centralities of nodes
node_prop <- list()
N <- nrow(dist)
for (i in 1:N) {
node_prop[[i]] = data.frame(x_cord = x_cord(i), y_cord = y_cord(i), compartment_id = comp(i), comp_size = cmtsize(i),
between_ct = between(i), close_ct = close(i), degree_ct = degree_centrality(i)
)
}
nodeproperties <- do.call(rbind, node_prop)
# based on user-defined threshold distance, remove nodes in comparmtnets of which distance to any of the plot margins < d
p1 <- nodeproperties$compartment_id[which(nodeproperties$y_cord > 270 - d)]
p2 <- nodeproperties$compartment_id[which(nodeproperties$y_cord < -270 + d)]
p3 <- nodeproperties$compartment_id[which(nodeproperties$x_cord < -240 + d)]
p4 <- nodeproperties$compartment_id[which(nodeproperties$x_cord > 240 - d)]
unidt1 <- unique(p1)
unidt2 <- unique(p2)
unidt3 <- unique(p3)
unidt4 <- unique(p4)
unidt <- unique(c(unidt1, unidt2, unidt3, unidt4))
library(Hmisc) #import Hmisc for dropping rows to be deleted due to the threshold distance
filtered_nodes <- subset(nodeproperties, compartment_id %nin% unidt)
# produce an edge table
edg_from <- function(x) replicate(length(which(DM[,x]!=0)),x)
edg_to <- function(x) which(DM[,x]!=0)
X_cord_from <- function(x) replicate(length(edg_from(x)), myCsv$Xplot[x])
Y_cord_from <- function(x) replicate(length(edg_from(x)), myCsv$Yplot[x])
X_cord_to <- function(x) myCsv$Xplot[which(DM[,x]!=0)]
Y_cord_to <- function(x) myCsv$Yplot[which(DM[,x]!=0)]
zz <- function(x) which(inv[,x]!=0)[1]
comp <- sapply(1:nrow(dist), zz)
compar <- function(x) replicate(length(which(DM[,x]!=0)), comp[x])
edg_f <- list()
N <- nrow(dist)
for (i in 1:N) {
edg_f[[i]] = data.frame(edge_from = edg_from(i), edge_to = edg_to(i), X_cord_from = X_cord_from(i), Y_cord_from = Y_cord_from(i), X_cord_to = X_cord_to(i), Y_cord_to = Y_cord_to(i), compartment_id = compar(i))
}
edges <- do.call(rbind, edg_f)
filtered_edges <- subset(edges, compartment_id %nin% unidt)
filtered_edges <- filtered_edges[,c(1:6)]
#return(filtered_edges)
networkstats <- unique(filtered_nodes[,c(3,4)])
compsize <- networkstats$comp_size
compsize_freq <- table(compsize)
return(list(nodes = filtered_nodes, edges = filtered_edges, compsize = compsize, compartments_table = table(networkstats)))
}
recnet(20)
nt <- function(d) {
DM <- matrix(0, nrow = nrow(dist), ncol = ncol(dist))
DM <- dist[] < d
diag(DM) = 0
I <- diag(1, nrow = nrow(dist), ncol = ncol(dist))
D <- sapply(1:nrow(dist), function(z) DM[,z]/(z+1))
inv <- solve(I-D)
edg_from <- function(x) replicate(length(which(DM[,x]!=0)),x)
edg_to <- function(x) which(DM[,x]!=0)
X_cord_from <- function(x) replicate(length(edg_from(x)), myCsv$Xplot[x])
Y_cord_from <- function(x) replicate(length(edg_from(x)), myCsv$Yplot[x])
X_cord_to <- function(x) myCsv$Xplot[which(DM[,x]!=0)]
Y_cord_to <- function(x) myCsv$Yplot[which(DM[,x]!=0)]
edg_f <- list()
N <- nrow(dist)
for (i in 1:N) {
edg_f[[i]] = data.frame(edg_from = edg_from(i), edg_to = edg_to(i), X_cord_from = X_cord_from(i), Y_cord_from = Y_cord_from(i), X_cord_to = X_cord_to(i), Y_cord_to = Y_cord_to(i))
}
edges <- do.call(rbind, edg_f)
id <- c(1:nrow(dist))
tt <- function(x) length(which(inv[,x]!=0))
compartment_size <- sapply(1:nrow(dist), tt)
zz <- function(x) which(inv[,x]!=0)[1] #this gives the first node of each compartment as a representative of the compartment label
compartment <- sapply(1:nrow(dist), zz)
x_cord <- function(x) data$x_cord[x] #x-coordinates of nodes
y_cord <- function(x) data$y_cord[x] #y-coordinates of nodes
cmtsize <- function(x) length(which(inv[,x]!=0)) #compartment sizes of nodes
comp <- function(x) which(inv[,x]!=0)[1] #compartment identities
g <- graph.adjacency(DM) #generate a graph
between <- function(x) betweenness(g, directed=FALSE)[x] #betweenness centralities of nodes
close <- function(x) closeness(g, mode = "out")[x] #closeness centralities of nodes
degree_centrality <- function(x) length(which(DM[,x]==1)) #degree centralities of nodes
vertices <- data.frame(id, x_cord, y_cord, compartment, compartment_size, between_ct, close_ct, degree_ct)
#vertices <- data.frame(id, cmtsize)
for_compsizefreq <- unique(vertices[,c(2,3)])
#compsize <- for_compsizefreq$cmtsize
#cmtsize_freq <- table(compsize)
#compartment_size_freq <- table(cmtsize)
return(list(nodes = vertices, edges = edges, compartments_table = table(for_compsizefreq)))
}
Nt(20)
nt(20)
nt <- function(d) {
DM <- matrix(0, nrow = nrow(dist), ncol = ncol(dist))
DM <- dist[] < d
diag(DM) = 0
I <- diag(1, nrow = nrow(dist), ncol = ncol(dist))
D <- sapply(1:nrow(dist), function(z) DM[,z]/(z+1))
inv <- solve(I-D)
edg_from <- function(x) replicate(length(which(DM[,x]!=0)),x)
edg_to <- function(x) which(DM[,x]!=0)
X_cord_from <- function(x) replicate(length(edg_from(x)), myCsv$Xplot[x])
Y_cord_from <- function(x) replicate(length(edg_from(x)), myCsv$Yplot[x])
X_cord_to <- function(x) myCsv$Xplot[which(DM[,x]!=0)]
Y_cord_to <- function(x) myCsv$Yplot[which(DM[,x]!=0)]
edg_f <- list()
N <- nrow(dist)
for (i in 1:N) {
edg_f[[i]] = data.frame(edg_from = edg_from(i), edg_to = edg_to(i), X_cord_from = X_cord_from(i), Y_cord_from = Y_cord_from(i), X_cord_to = X_cord_to(i), Y_cord_to = Y_cord_to(i))
}
edges <- do.call(rbind, edg_f)
id <- c(1:nrow(dist))
tt <- function(x) length(which(inv[,x]!=0))
compartment_size <- sapply(1:nrow(dist), tt)
zz <- function(x) which(inv[,x]!=0)[1] #this gives the first node of each compartment as a representative of the compartment label
compartment <- sapply(1:nrow(dist), zz)
x_cord <- function(x) data$x_cord[x] #x-coordinates of nodes
y_cord <- function(x) data$y_cord[x] #y-coordinates of nodes
cmtsize <- function(x) length(which(inv[,x]!=0)) #compartment sizes of nodes
comp <- function(x) which(inv[,x]!=0)[1] #compartment identities
g <- graph.adjacency(DM) #generate a graph
between <- function(x) betweenness(g, directed=FALSE)[x] #betweenness centralities of nodes
close <- function(x) closeness(g, mode = "out")[x] #closeness centralities of nodes
degree_centrality <- function(x) length(which(DM[,x]==1)) #degree centralities of nodes
vertices <- data.frame(id, x_cord, y_cord, compartment, compartment_size, between_ct = between, close_ct = close, degree_ct = degree)
#vertices <- data.frame(id, cmtsize)
for_compsizefreq <- unique(vertices[,c(2,3)])
#compsize <- for_compsizefreq$cmtsize
#cmtsize_freq <- table(compsize)
#compartment_size_freq <- table(cmtsize)
return(list(nodes = vertices, edges = edges, compartments_table = table(for_compsizefreq)))
}
nt(20)
recnet_exp <- function(d, lambda) {
#based on user-defined threshold distance, d, to create an adjancency matrix of nodes
prob <- exp(-lambda * dist)
DM <- rbinom(length(prob), size = 1, prob =  prob) #the problem with stochasticity is the network becomes directional
DM <- matrix(DM, nrow = nrow(dist), ncol = ncol(dist))
DM[lower.tri(DM)] <- (t(DM)[lower.tri(DM)] == 1)
diag(DM) = 0
I <- diag(1, nrow=nrow(dist), ncol=ncol(dist))
#the application of the fundamental matrix of Markov Chain to generate information of comparments
D <- matrix(0, nrow=nrow(dist), ncol = ncol(dist))
D <- sapply(1:nrow(dist), function(z) DM[,z]/(z+1))
inv <- solve(I-D)
# collect node properties of the network
x_cord <- function(x) data$x_cord[x] #x-coordinates of nodes
y_cord <- function(x) data$y_cord[x] #y-coordinates of nodes
cmtsize <- function(x) length(which(inv[,x]!=0)) #compartment sizes of nodes
comp <- function(x) which(inv[,x]!=0)[1] #compartment identities
g <- graph.adjacency(DM) #generate a graph
between <- function(x) betweenness(g, directed=FALSE)[x] #betweenness centralities of nodes
close <- function(x) closeness(g, mode = "out")[x] #closeness centralities of nodes
degree_centrality <- function(x) length(which(DM[,x]==1)) #degree centralities of nodes
node_prop <- list()
N <- nrow(dist)
for (i in 1:N) {
node_prop[[i]] = data.frame(x_cord = x_cord(i), y_cord = y_cord(i), compartment_id = comp(i), comp_size = cmtsize(i),
between_ct = between(i), close_ct = close(i), degree_ct = degree_centrality(i)
)
}
nodeproperties <- do.call(rbind, node_prop)
# based on user-defined threshold distance, remove nodes in comparmtnets of which distance to any of the plot margins < d
p1 <- nodeproperties$compartment_id[which(nodeproperties$y_cord > 270 - d)]
p2 <- nodeproperties$compartment_id[which(nodeproperties$y_cord < -270 + d)]
p3 <- nodeproperties$compartment_id[which(nodeproperties$x_cord < -240 + d)]
p4 <- nodeproperties$compartment_id[which(nodeproperties$x_cord > 240 - d)]
unidt1 <- unique(p1)
unidt2 <- unique(p2)
unidt3 <- unique(p3)
unidt4 <- unique(p4)
unidt <- unique(c(unidt1, unidt2, unidt3, unidt4))
library(Hmisc) #import Hmisc for dropping rows to be deleted due to the threshold distance
filtered_nodes <- subset(nodeproperties, compartment_id %nin% unidt)
# produce an edge table
edg_from <- function(x) replicate(length(which(DM[,x]!=0)),x)
edg_to <- function(x) which(DM[,x]!=0)
X_cord_from <- function(x) replicate(length(edg_from(x)), myCsv$Xplot[x])
Y_cord_from <- function(x) replicate(length(edg_from(x)), myCsv$Yplot[x])
X_cord_to <- function(x) myCsv$Xplot[which(DM[,x]!=0)]
Y_cord_to <- function(x) myCsv$Yplot[which(DM[,x]!=0)]
zz <- function(x) which(inv[,x]!=0)[1]
comp <- sapply(1:nrow(dist), zz)
compar <- function(x) replicate(length(which(DM[,x]!=0)), comp[x])
edg_f <- list()
N <- nrow(dist)
for (i in 1:N) {
edg_f[[i]] = data.frame(edge_from = edg_from(i), edge_to = edg_to(i), X_cord_from = X_cord_from(i), Y_cord_from = Y_cord_from(i), X_cord_to = X_cord_to(i), Y_cord_to = Y_cord_to(i), compartment_id = compar(i))
}
edges <- do.call(rbind, edg_f)
filtered_edges <- subset(edges, compartment_id %nin% unidt)
filtered_edges <- filtered_edges[,c(1:6)]
#return(filtered_edges)
networkstats <- unique(filtered_nodes[,c(3,4)])
compsize <- networkstats$comp_size
compsize_freq <- table(compsize)
return(list(nodes = filtered_nodes, edges = filtered_edges, compsize = compsize, compartments_table = table(networkstats)))
}
recnet_exp(20,0.04)
library("devtools")
library(roxygen2)
library(roxygen2)
setwd("/Users/achimnyswallow/Documents/Projects/R package ulnet")
create("Ulnet")
source('~/Documents/Projects/R package ulnet/recnet.R')
setwd("./Ulnet")
getwd()
document()
setwd("..")
install("Ulnet")
install.packages(c("devtools", "roxygen2", "testthat", "knitr"))
install.packages(c("devtools", "roxygen2", "testthat", "knitr"))
install.packages("rstudioapi")
rstudioapi::isAvailable("0.99.149")
devtools::install_github("hadley/devtools")
library(devtools)
has_devel()
library(roxygen2)
library(roxygen2)
library(testthat)
library(testthat)
devtoos::session_info()
devtools::session_info()
library(rmarkdown)
devtools::session_info()
library(knitr)
library(knitr)
devtools::session_info()
library(formatR)
library(formatR)
devtools::session_info()
